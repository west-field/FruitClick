#include "Mouse.h"
#include <DxLib.h>
#include "DrawFunctions.h"
#include "../game.h"

namespace
{
	constexpr int kClickImgWidth = 100;//画像サイズX
	constexpr int kClickImgHeight = 100;//画像サイズY
	constexpr float kClickDrawScale = 1.0f;//拡大率
	constexpr int kClickAnimNum = 31;//アニメーション枚数
	constexpr int  kClickAnimSpeed = 1;//アニメーションスピード
}

Mouse::Mouse() :mouseLog(), m_rect{ {},{} }
{
	m_rect = { {},{} };
	m_mouseH = my::MyLoadGraph(L"Data/Cursor.png");
	m_ripplesH = my::MyLoadGraph(L"Data/ripples.png");
	MouseReset();
}

Mouse::~Mouse()
{
	DeleteGraph(m_mouseH);
}

void Mouse::Update()
{
	//ログの更新
	for (int i = kLogNum - 1; i >= 1; i--)
	{
		mouseLog[i] = mouseLog[i - 1];
	}

	//最新の状態
	if ((GetMouseInput() & MOUSE_INPUT_LEFT) != 0)
	{
		mouseLog[0] = 1;
		if (IsTriggerLeft())
		{
			ClickAnimCreate();
		}
	}
	else if ((GetMouseInput() & MOUSE_INPUT_RIGHT) != 0)
	{
		mouseLog[0] = 2;
		if (IsTriggerRight())
		{
			ClickAnimCreate();
		}
	}
	else
	{
		mouseLog[0] = 0;
	}

	RipplesAnimUpdate();


	m_rect.center = GetPos();
}

void Mouse::Draw()
{
	//波紋を表示する
	for (auto& ripples : m_ripples)
	{
		//波紋を表示できるとき
		if (ripples.isDisplay)
		{
			int animNum = static_cast<int>(ripples.idx / kClickAnimSpeed);
			if (animNum >= kClickAnimNum)
			{
				animNum -= kClickAnimNum;
			}
			int imgX = animNum % 6 * kClickImgWidth;
			int imgY = animNum / 6 * kClickImgHeight;
			my::MyDrawRectRotaGraph(ripples.pos.x, ripples.pos.y, imgX, imgY, kClickImgWidth, kClickImgHeight, kClickDrawScale, 0.0f, m_ripplesH, true, false);
		}
	}
	my::MyDrawGraph(static_cast<int>(m_rect.center.x), static_cast<int>(m_rect.center.y), m_mouseH, true);
#ifdef _DEBUG
	DrawFormatStringF(m_rect.center.x, m_rect.center.y, 0xffffff, L"-----x%3f,y%3f", m_rect.center.x, m_rect.center.y);
#endif
}

void Mouse::MouseReset()
{
	SetMousePoint(Game::kScreenWidth / 2, Game::kScreenHeight / 2);//ポインタを中心に移動させる
}

Position2 Mouse::GetPos() const
{
	int mouseX = 0;//マウスカーソルx座標
	int mouseY = 0;//マウスカーソルy座標

	//マウスカーソルの位置を取得する関数の返り値が-1の時
	if (GetMousePoint(&mouseX, &mouseY) == -1)
	{
		//エラー発生
		return Position2(0, 0);
	}

	return Position2(static_cast<float>(mouseX), static_cast<float>(mouseY));
}

bool Mouse::IsPressLeft()
{
	//最新のログが1の時押されている
	return (mouseLog[0] == 1);
}

bool Mouse::IsPressRight()
{
	//最新のログが2の時押されている
	return (mouseLog[0] == 2);
}

bool Mouse::IsTriggerLeft()
{
	bool isNow = (mouseLog[0] == 1);//現在の状態
	bool isLast = (mouseLog[1]);//1フレーム前の状態
	return (isNow && !isLast);//今押していて、1フレーム前押されていなかったとき押せる
}

bool Mouse::IsTriggerRight()
{
	bool isNow = (mouseLog[0] == 2);//現在の状態
	bool isLast = (mouseLog[1]);//1フレーム前の状態
	return (isNow && !isLast);//今押していて、1フレーム前押されていなかったとき押せる
}

bool Mouse::IsRelaseLeft()
{
	bool isNow = (mouseLog[0] == 1);//現在の状態
	bool isLast = (mouseLog[1]);//1フレーム前の状態
	return (!isNow && isLast);//今離していて、1フレーム前押されていたとき離した判定になる
}

bool Mouse::IsRelaseRight()
{
	bool isNow = (mouseLog[0] == 2);//現在の状態
	bool isLast = (mouseLog[1]);//1フレーム前の状態
	return (!isNow && isLast);//今離していて、1フレーム前押されていたとき離した判定になる
}

//当たり判定
Rect Mouse::GetRect() const
{
	return m_rect;
}

//カーソルの位置がメニュー位置にいるかどうか
bool Mouse::MouseSelect(int startX, int endX, int startY, int endY)
{
	
	if (m_rect.center.y < startY)	return false;
	if (m_rect.center.y > endY)		return false;
	if (m_rect.center.x < startX)	return false;
	if (m_rect.center.x > endX)		return false;

	//マウスの位置が範囲内にある
	return true;
}

bool Mouse::MouseSelect(float startX, float endX, float startY, float endY)
{
	if (m_rect.center.y < startY)	return false;
	if (m_rect.center.y > endY)		return false;
	if (m_rect.center.x < startX)	return false;
	if (m_rect.center.x > endX)		return false;

	//マウスの位置が範囲内にある
	return true;
}

//波紋作成
void Mouse::ClickAnimCreate()
{
	Ripples ripples;
	ripples.pos = m_rect.center;//現在の位置
	ripples.isDisplay = true;//波紋を表示する
	ripples.idx = 0;//一番最初の絵のインデックス

	//一番後ろに入れる
	m_ripples.push_back(ripples);
}

//波紋の更新
void Mouse::RipplesAnimUpdate()
{
	for (auto& ripples : m_ripples)
	{
		//既に表示できなくなっている時は処理しない
		if (!ripples.isDisplay)	continue;

		//インデックスがアニメーション枚数以上のとき
		if (ripples.idx++ >= kClickAnimNum * kClickAnimSpeed)
		{
			ripples.idx = 0;
			ripples.isDisplay = false;
		}
	}

	//いらなくなったものを削除
	m_ripples.remove_if([](const Ripples click) {
		return !click.isDisplay;
		});
}

